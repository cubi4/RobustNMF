var documenterSearchIndex = {"docs":
[{"location":"functions/#RobustNMF","page":"Functions","title":"RobustNMF","text":"Documentation for RobustNMF.\n\n","category":"section"},{"location":"functions/#RobustNMF.Data.add_gaussian_noise!-Tuple{AbstractMatrix}","page":"Functions","title":"RobustNMF.Data.add_gaussian_noise!","text":"add_gaussian_noise!(X::AbstractMatrix; σ::Float64=0.1, clip_at_zero::Bool=true)\n\nAdd Gaussian noise with standard deviation σ to the matrix X in-place.\n\nIf clip_at_zero is true, replace all negative entries of X with 0.0 after adding noise, to preserve non-negativity.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.Data.add_sparse_outliers!-Tuple{AbstractMatrix}","page":"Functions","title":"RobustNMF.Data.add_sparse_outliers!","text":"add_sparse_outliers!(X::AbstractMatrix; fraction::Float64=0.01, magnitude::Float64=5.0, \nseed=nothing)\n\nAdd sparcse, large positive outliers to a fraction of the entries of X in-place.\n\nfraction controls the proportion of entries that are modified. Each selected entry is increased by a random value drawn from Uniform(0, magnitude). If seed is provided, the random choices are reproducible.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.Data.generate_synthetic_data-Tuple{Int64, Int64}","page":"Functions","title":"RobustNMF.Data.generate_synthetic_data","text":"generate_synthetic_data(m::Int, n::Int; rank::Int=10, noise_level::Float64=0.0, seed=nothing)\n\nGenerate a non-negative matrix X ∈ R^{m×n} by sampling non-negative factors W (m×rank) and H (rank×n) and returning (X, W, H).\n\nOptionally add Gaussian noise with standard deviation noise_level and clip the result at 0.0 to keep X non-negative.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.Data.load_image_folder-Tuple{AbstractString}","page":"Functions","title":"RobustNMF.Data.load_image_folder","text":"load_image_folder(dir::AbstractString; pattern::AbstractString=\"*.png\", normalize::Bool=true)\n\nLoad all images in dir whose filenames match pattern, convert them to grayscale if needed, flatten them, and stack them as columns of a data matrix X.\n\nReturns a tuple (X, (height, width), filenames), where:\n\nX :: Matrix{Float64} has one column per image,\n(height, width) is the original image size,\nfilenames is a vector of the loaded base filenames.\n\nIf normalize is true, the matrix X is shifted and rescaled to be non-negative with entries in [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.Data.normalize_nonnegative!-Tuple{AbstractMatrix}","page":"Functions","title":"RobustNMF.Data.normalize_nonnegative!","text":"normalize_nonnegative!(X::AbstractMatrix; rescale::Bool=true)\n\nShift the matrix X in-place so that its minimum value becomes 0.0 if it is negative. If rescale is true, also divide X by its maximum value so that all entries lie in the interval [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"functions/#RobustNMF.StandardNMF.nmf-Tuple{Any}","page":"Functions","title":"RobustNMF.StandardNMF.nmf","text":" nmf(X; rank::Int=10, maxiter::Int=500, tol::Float64=1e-4)\n\nCompute a standard Non-negative Matrix Factorization (NMF) of the non-negative data matrix X ∈ ℝ^{m×n} using multiplicative update rules and an L2 (Frobenius) reconstruction loss. \n\nReturns\n\nW: non-negative basis matrix of size (m, rank)\nH: non-negative coefficient matrix of size (rank, n)\nhistory: vector containing the Frobenius reconstruction error at each iteration\n\nThe reconstructed data matrix can be obtained as W * H.\n\n\n\n\n\n","category":"method"},{"location":"#Getting-Started-with-RobustNMF.jl","page":"Getting Started","title":"Getting Started with RobustNMF.jl","text":"","category":"section"},{"location":"#Installation","page":"Getting Started","title":"Installation","text":"Clone the repository and activate the project environment. The following steps work when executed from the repository root directory.\n\n# Enter the Julia package manager\n]\n\n# Activate the local project environment\nactivate .\n\n# Install all required dependencies\ninstantiate","category":"section"},{"location":"#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"Import the package:\n\nusing RobustNMF","category":"section"},{"location":"#Simple-Example","page":"Getting Started","title":"Simple Example","text":"Perform robust non-negative matrix factorization:\n\n\n# Generate synthetic non-negative data\nX, W, H = generate_synthetic_data(20, 30)\n\n# Add Gaussian noise (in-place)\nadd_gaussian_noise!(X, σ = 0.2)\n\n# Add sparse outliers (in-place)\nadd_sparse_outliers!(X, fraction = 0.04, magnitude = 5.2)\n\n# Normalize and rescale data to non-negative range\nnormalize_nonnegative!(X)\n\n# Run standard NMF\nW_nmf, H_nmf, history = nmf(X, rank = 12, maxiter = 3000, tol = 1e-6)\n\n# Reconstruct the data matrix (X)\nX_rec = W_nmf * H_nmf\n\n\n","category":"section"},{"location":"#Notes","page":"Getting Started","title":"Notes","text":"All input data must be non-negative.\nFunctions with a ! modify their input in-place.\nThe reconstructed matrix X_rec approximates the original data X.","category":"section"}]
}
